##### Разработка: Александрос Тосунидис
#### Съдържание:
1. **Въведение в C++**
- Compilers ( Компилатори )
2. **Основи на C++**
- Структура на програмата
- Променливи и Типове
- Константи
- Оператори
- Вход/Изход
3. **Структура на програмата**
- Statement-и и контрол на потока
- Функции
- Претоварвания и шаблони
4. **Съставни типове данни**
- Масиви
- Последователност от знаци
- Указатели
- Динамична памет
- Структури от данни
- Други типове данни
5. **Класове**
- Класове №1
- Класове №2
- Специални членове
- Наследяване
- Полиморфизъм
6. **Други езикови особености**
- Типови преобразувания
- Изключения
- Директиви за препроцесор
7. **Стандартна библиотека**
- Вход/Изход с файлове

##### Среди за разработки: VS Code, Visual Studio 2019/2022, XCode, GNU, Code::Blocks, Eclipse

--------------------------------------------------------------------------

# Въведение в C++

### Compilers ( Компилатори )

Компютрите разбират само един език и този език се състои от набори от инструкции, съставени от единици и нули. Този компютърен език е подходящо да се нарича _машинен език_ .  
  
Една единствена инструкция към компютър може да изглежда така:

|   |   |
|---|---|
|00000|10011110|

Програмата на определен компютър на машинен език, която позволява на потребителя да въведе две числа, събира двете числа заедно и показва общата сума, може да включва следните инструкции за машинен код:

|       |          |
| ----- | -------- |
| 00000 | 10011110 |
| 00001 | 11110100 |
| 00010 | 10011110 |
| 00011 | 11010100 |
| 00100 | 10111111 |
| 00101 | 00000000 |

Това е част от код, написан на C++, който изпълнява точно същата цел:

```cpp
int a, b, sum;
     
cin >> a;
cin >> b;
             
sum = a + b;
cout << sum << endl;
```

Тъй като компютърът може да разбира само машинния език, а хората искат да пишат на езици от високо ниво, езиците от високо ниво трябва да бъдат пренаписани (преведени) на машинен език в даден момент. Това се прави от специални програми, наречени компилатори, интерпретатори или асемблери, които са вградени в различните приложения за програмиране.

### Конзолни програми

Конзолните програми са програми, които използват текст за комуникация с потребителя и околната среда, като например отпечатване на текст на екрана или четене на въведени данни от клавиатура.  
  
Конзолните програми са лесни за взаимодействие и обикновено имат предвидимо поведение, което е идентично във всички платформи. Те също така са лесни за изпълнение и по този начин са много полезни за изучаване на основите на езика за програмиране: примерите в тези уроци са всички конзолни програми.  
  
Начинът за компилиране на конзолни програми зависи от конкретния инструмент, който използвате.  
  
Най-лесният начин за начинаещи да компилират C++ програми е с помощта на интегрирана среда за разработка (IDE). IDE обикновено интегрира няколко инструмента за разработка, включително текстов редактор и инструменти за компилиране на програми директно от него.  
  
Тук имате инструкции как да компилирате и изпълнявате конзолни програми, като използвате различни безплатни интегрирани интерфейси за разработка (IDE):

| IDE                       | Platform            | Console programs                                                                                                |
| ------------------------- | ------------------- | --------------------------------------------------------------------------------------------------------------- |
| **Code::blocks**          | Windows/Linux/MacOS | [Compile console programs using Code::blocks](https://cplusplus.com/doc/tutorial/introduction/codeblocks/)      |
| **Visual Studio Express** | Windows             | [Compile console programs using VS Express 2013](https://cplusplus.com/doc/tutorial/introduction/visualstudio/) |
| **Dev-C++**               | Windows             | [Compile console programs using Dev-C++](https://cplusplus.com/doc/tutorial/introduction/devcpp/)               |

Ако случайно имате Linux или Mac среда с функции за разработка, трябва да можете да компилирате който и да е от примерите директно от терминал само като включите C++11 флагове в командата за компилатора:

|Compiler|Platform|Command|
|---|---|---|
|**GCC**|Linux, among others...|`g++ -std=c++0x example.cpp -o example_program`|
|**Clang**|OS X, among others...|`clang++ -std=c++11 -stdlib=libc++ example.cpp -o example_program`|

# Основи на C++

### Структура на програмата

```cpp
// my first program in C++
#include <iostream>

int main()
{
  std::cout << "Hello World!";
}
```

- Output: Здравей свят!

Горният панел показва C++ кода за тази програма. Output-а показва резултата, когато програмата се изпълнява от компютър.

Кодът обяснен ред по ред:

Ред 1:`// my first program in C++`

Две наклонени черти показват, че останалата част от реда е коментар, вмъкнат от програмиста, но който няма ефект върху поведението на програмата. Програмистите ги използват, за да включат кратки обяснения или наблюдения относно кода или програмата. В този случай това е кратко уводно описание на програмата.

Ред 2:`#include <iostream>`

Редовете, започващи с решетка ( `#`) са директиви, прочетени и интерпретирани от това, което е известно като _препроцесор_ . Те са специални редове, интерпретирани преди да започне компилирането на самата програма. В този случай директивата `#include <iostream>`инструктира препроцесора да включи раздел от стандартен C++ код, известен като _заглавка iostream_ , който позволява извършването на стандартни входни и изходни операции, като писане на изхода на тази програма (Здравей свят) към екрана.

Ред 3: Празен ред.

Празните редове нямат ефект върху програмата. Те просто подобряват четливостта на кода.

Ред 4:`int main ()`

Този ред инициира декларирането на функция. По същество функцията е група кодови изрази, на които е дадено име: в този случай това дава името "main" на групата кодови изрази, които следват. Функциите ще бъдат обсъдени подробно в следваща глава, но по същество тяхната дефиниция е въведена с последователност от тип ( `int`), име ( `main`) и двойка скоби ( `()`), по избор включващи параметри.  
  
Посочената функция `main`е специална функция във всички C++ програми; това е функцията, която се извиква, когато програмата се изпълнява. Изпълнението на всички C++ програми започва с `main`функцията, независимо къде всъщност се намира функцията в кода.

Редове 5 и 7: `{`и`}`

Отворената скоба ( `{`) на ред 5 показва началото на `main`дефиницията на функцията, а затварящата скоба ( `}`) на ред 7 показва нейния край. Всичко между тези скоби е тялото на функцията, което определя какво се случва при `main`извикване. Всички функции използват скоби, за да укажат началото и края на своите дефиниции.

Ред 6:`std::cout << "Hello World!";`

Този ред е израз на C++. Изявлението е израз, който действително може да произведе някакъв ефект. Това е тялото на програма, определящо нейното действително поведение. Изявленията се изпълняват в същия ред, в който се появяват в тялото на функцията. Това твърдение има **три**  части: 

Първо, `std::cout`, което идентифицира **стандартното** устройство за извеждане **на символи** **(** обикновено това е екранът на компютъра). 

Второ, операторът за вмъкване ( << ), който показва, че това, което следва, е вмъкнато в `std::cout` . И накрая, изречение в кавички („Здравей свят!“) е съдържанието, вмъкнато в стандартния изход. Забележете, че изразът завършва с точка и запетая ( ; ). Този знак отбелязва края на израза, точно както точката завършва изречение на английски. Всички оператори на C++ трябва да завършват с точка и запетая. Една от най-честите синтактични грешки в C++ е забравянето да завършите израз с точка и запетая.`<<``std::cout`  
  
`;`  

  
Може би сте забелязали, че не всички редове на тази програма изпълняват действия, когато кодът се изпълнява. Има ред, съдържащ коментар (започващ с `//`). Има ред с директива за препроцесора (започващ с `#`). Има ред, който дефинира функция (в този случай функцията `main`). И накрая, ред с изрази, завършващи с точка и запетая (вмъкването в `cout`), който беше в рамките на блока, ограничен от скобите ( `{ }`) на `main`функцията.

Програмата е структурирана в различни редове и с подходящ отстъп, за да бъде по-лесна за разбиране от хората, които я четат. Но C++ няма строги правила за отстъпи или за това как да се разделят инструкциите в различни редове. Например, вместо

```cpp
int main ()
{
  std::cout << " Hello World!";
}
```

Можем да напишем:

```cpp
int main () { std::cout << "Hello World!"; }
```

В C++ разделянето между изразите се определя с крайна точка и запетая ( `;`), като разделянето на различни редове няма никакво значение за тази цел. Много твърдения могат да бъдат написани на един ред или всяко твърдение може да бъде на отделен ред. Разделянето на кода на различни редове служи само за да го направи по-четлив и схематичен за хората, които могат да го прочетат, но няма ефект върху действителното поведение на програмата.  
  
Сега нека добавим допълнителен оператор към нашата първа програма:

```cpp
// my second program in C++
#include <iostream>

int main ()
{
  std::cout << "Hello World! ";
  std::cout << "I'm a C++ program";
}
```

- Output: Здравей свят! Аз съм C++ програма

В този случай програмата извърши две вмъквания в `std::cout`два различни оператора. Още веднъж, разделянето в различни редове код просто дава по-голяма четливост на програмата, тъй като `main`би могло да бъде напълно валидно дефинирано по този начин:

```cpp
int main () { std::cout << " Hello World! "; std::cout << " I'm a C++ program "; }
```

Вместо това изходният код може също да бъде разделен на повече кодови редове:

```cpp
int main ()
{
  std::cout <<
    "Hello World!";
  std::cout
    << "I'm a C++ program";
}
```

Директивите на препроцесора (тези, които започват с `#`) са извън това общо правило, тъй като не са изрази. Те са редове, прочетени и обработени от препроцесора, преди да започне правилното компилиране. Директивите на препроцесора трябва да бъдат посочени в собствен ред и, тъй като не са изрази, не трябва да завършват с точка и запетая ( `;`).

### Коментари

C++ поддържа два начина за коментиране на код:

```cpp
// line comment
/* block comment */
```

Първият от тях, известен като _коментар за ред_ , отхвърля всичко от мястото, където се намира двойката наклонени черти ( `//`) до края на същия ред. Вторият, известен като _блоков коментар_ , отхвърля всичко между `/*`знаците и първата поява на `*/`знаците, с възможност за включване на няколко реда.

Нека добавим коментари към нашата втора програма:

```cpp
/* my second program in C++
   with more comments */

#include <iostream>

int main ()
{
  std::cout << "Hello World! ";     // prints Hello World!
  std::cout << "I'm a C++ program"; // prints I'm a C++ program
}
```

Ако коментарите са включени в изходния код на програма, без да се използват комбинациите от знаци за коментар `//`, `/*`или `*/`, компилаторът ги приема като C++ изрази, което най-вероятно причинява неуспех на компилацията с едно или няколко съобщения за грешка.

### Използване на пространство от имена std

Ако сте виждали C++ код преди, може да сте виждали `cout`да се използва вместо `std::cout`. И двата наименуват един и същи обект: първият използва _неквалифицираното си име_ ( `cout`), докато вторият го квалифицира директно в _пространството от имена_ `std` (като `std::cout`).  
  
`cout`е част от стандартната библиотека и всички елементи в стандартната C++ библиотека са декларирани в това, което се нарича _пространство от имена_ : пространството от имена `std`.  
  
За да се позовава на елементите в `std`пространството от имена, програмата трябва или да квалифицира всяка употреба на елементи от библиотеката (както направихме с префикс `cout`с `std::`), или да въведе видимост на нейните компоненти. Най-типичният начин за въвеждане на видимост на тези компоненти е чрез _използване на декларации_ :

```cpp
using namespace std;
```

Горната декларация позволява всички елементи в `std`пространството от имена да бъдат достъпни по _неквалифициран_ начин (без `std::`префикса).

Имайки това предвид, последният пример може да бъде пренаписан, за да се използва неквалифицирано `cout`като:

```cpp
// my second program in C++
#include <iostream>
using namespace std;

int main ()
{
  cout << "Hello World! ";
  cout << "I'm a C++ program";
}
```

И двата начина за достъп до елементите на пространството от `std`имена (явна квалификация и _използване_ на декларации) са валидни в C++ и произвеждат абсолютно същото поведение. За опростяване и за подобряване на четливостта, примерите в тези уроци ще използват по-често този последен подход с _използване_ на декларации, въпреки че имайте предвид, че _изричната квалификация_ е единственият начин да се гарантира, че никога няма да се сблъскат имена.  
  
Пространствата от имена са обяснени по-подробно в следваща глава.

### Променливи и Типове

Полезността на програмите "Hello World", показани в предишната глава, е доста съмнителна. Трябваше да напишем няколко реда код, да ги компилираме и след това да изпълним получената програма, само за да получим резултата от просто изречение, написано на екрана. Със сигурност би било много по-бързо да напишем сами изходното изречение.  
  
Програмирането обаче не се ограничава само до отпечатване на прости текстове на екрана. За да отидем малко по-нататък и да можем да пишем програми, които изпълняват полезни задачи, които наистина ни спестяват работа, трябва да въведем концепцията за _променливи_ .  
  
Нека си представим, че ви моля да запомните числото 5, а след това ви моля да запомните и числото 2 в същото време. Току-що сте съхранили две различни стойности в паметта си (5 и 2). Сега, ако ви помоля да добавите 1 към първото число, което казах, трябва да запазите числата 6 (това е 5+1) и 2 в паметта си. Тогава бихме могли, например, да извадим тези стойности и да получим 4 като резултат.

Целият процес, описан по-горе, е подобие на това, което един компютър може да направи с две променливи. Същият процес може да бъде изразен в C++ със следния набор от изрази:

```cpp
a = 5;
b = 2;
a = a + 1;
result = a - b;
```

Вече можем да дефинираме променливата като част от паметта за съхраняване на стойност.  
  
Всяка променлива се нуждае от име, което да я идентифицира и отличава от другите. Например в предишния код имената на променливите бяха `a`, `b`и `result`, но можехме да наречем променливите всякакви имена, които можехме да измислим, стига да бяха валидни C++ идентификатори.

### Идентификатори

Валиден идентификатор е поредица от една или повече букви, цифри или долна черта ( `_`). Интервали, препинателни знаци и символи не могат да бъдат част от идентификатор. Освен това идентификаторите винаги започват с буква. Те могат също да започват със знак за подчертаване ( `_`), но такива идентификатори - в повечето случаи - се считат за запазени за специфични за компилатора ключови думи или външни идентификатори, както и идентификатори, съдържащи два последователни знака за подчертаване навсякъде. В никакъв случай не могат да започват с цифра.  
  
C++ използва редица ключови думи за идентифициране на операции и описания на данни; следователно идентификаторите, създадени от програмист, не могат да съответстват на тези ключови думи. Стандартните запазени ключови думи, които не могат да се използват за идентификатори, създадени от програмист, са: Специфичните компилатори може също да имат допълнителни специфични резервирани ключови думи. **Много важно:** Езикът C++ е "чувствителен към малки и малки букви". Това означава, че идентификатор, написан с главни букви, не е еквивалентен на друг идентификатор със същото име, но написан с малки букви. Така например променливата не е същата като променливата или променливата. Това са три различни идентификатора, идентифициращи три различни променливи.  
  
`alignas, alignof, and, and_eq, asm, auto, bitand, bitor, bool, break, case, catch, char, char16_t, char32_t, class, compl, const, constexpr, const_cast, continue, decltype, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, new, noexcept, not, not_eq, nullptr, operator, or, or_eq, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_assert, static_cast, struct, switch, template, this, thread_local, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while, xor, xor_eq`

### Основни типове данни

Стойностите на променливите се съхраняват някъде на неопределено място в паметта на компютъра като нули и единици. Нашата програма не трябва да знае точното местоположение, където се съхранява променливата; той може просто да се позовава на него с името му. Това, което програмата трябва да знае, е вида на данните, съхранявани в променливата. Не е същото да съхранявате просто цяло число, както е да съхранявате буква или голямо число с плаваща запетая; въпреки че всички те са представени с помощта на нули и единици, те не се интерпретират по същия начин и в много случаи не заемат същото количество памет.  
  
Фундаменталните типове данни са основни типове, реализирани директно от езика, който представлява основните единици за съхранение, поддържани естествено от повечето системи. Те могат да бъдат класифицирани основно в:  

- **Типове символи:** Те могат да представляват един знак, като `'A'`или `'$'`. Най-основният тип е `char`, който е еднобайтов знак. Предлагат се и други типове за по-широки знаци.
- **Числови цели числа ( int ):** Те могат да съхраняват цяло число, като `7`или `1024`. Те съществуват в различни размери и могат да бъдат _със знак_ или _без знак_ , в зависимост от това дали поддържат отрицателни стойности или не.
- **Типове с плаваща запетая ( float ):** Те могат да представят реални стойности, като `3.14`или `0.01`, с различни нива на точност, в зависимост от това кой от трите типа с плаваща запетая се използва.
- **Булев тип ( bool ):** Булевият тип, известен в C++ като `bool`, може да представлява само едно от двете състояния `true`или `false`.

Ето пълния списък на основните типове в C++:  
  

| Група                          | Въведете имена*                                            | Бележки за размера/прецизността              |
| ------------------------------ | ---------------------------------------------------------- | -------------------------------------------- |
| Типове знаци                   | `**char**`                                                 | Точно един байт в размер. Най-малко 8 бита.  |
| `**char16_t**`                 | Не по-малко от `char`. Най-малко 16 бита.                  |                                              |
| `**char32_t**`                 | Не по-малко от `char16_t`. Най-малко 32 бита.              |                                              |
| `**wchar_t**`                  | Може да представлява най-големия поддържан набор от знаци. |                                              |
| Типове цели числа (знак)       | `**signed char**`                                          | Същият размер като `char`. Най-малко 8 бита. |
| `_signed_ **short** _int_`     | Не по-малко от `char`. Най-малко 16 бита.                  |                                              |
| `_signed_ **int**`             | Не по-малко от `short`. Най-малко 16 бита.                 |                                              |
| `_signed_ **long** _int_`      | Не по-малко от `int`. Най-малко 32 бита.                   |                                              |
| `_signed_ **long long** _int_` | Не по-малко от `long`. Най-малко 64 бита.                  |                                              |
| Типове цели числа (без знак)   | `**unsigned char**`                                        | (същия размер като техните подписани копия)  |
| `**unsigned short** _int_`     |                                                            |                                              |
| `**unsigned** _int_`           |                                                            |                                              |
| `**unsigned long** _int_`      |                                                            |                                              |
| `**unsigned long long** _int_` |                                                            |                                              |
| Типове с плаваща запетая       | `**float**`                                                |                                              |
| `**double**`                   | Точност не по-малка от`float`                              |                                              |
| `**long double**`              | Точност не по-малка от`double`                             |                                              |
| Булев тип                      | `**bool**`                                                 |                                              |
| Празен тип                     | `**void**`                                                 | без съхранение                               |
| Нулев указател                 | `**decltype(nullptr)**`                                    |                                              |
* Имената на определени цели типове могат да бъдат съкратени без техните `signed`и `int`компоненти - само частта, която не е в курсив, е необходима за идентифициране на типа, частта в курсив е по избор. Т.е., може да бъде съкратено като , или просто ; всички те идентифицират един и същ основен тип. Във всяка от групите по-горе разликата между типовете е само техният размер (т.е. колко заемат в паметта): първият тип във всяка група е най-малкият, а последният е най-големият, като всеки тип е поне колкото голям като този, който го предхожда в същата група. Освен това, типовете в група имат едни и същи свойства. Забележете в панела по-горе, че освен (който има размер точно един байт), нито един от основните типове няма зададен стандартен размер (но най-много минимален размер). Следователно типът не е задължителен (и в много случаи не е) точно този минимален размер. Това не означава, че тези типове са с неопределен размер, а че няма стандартен размер за всички компилатори и машини; всяка реализация на компилатор може да посочи размерите за тези типове, които отговарят най-добре на архитектурата, където програмата ще се изпълнява. Тази доста обща спецификация на размера на типовете дава на езика C++ много гъвкавост, за да бъде адаптиран да работи оптимално във всички видове платформи, както настоящи, така и бъдещи. Типовите размери по-горе са изразени в битове; колкото повече битове има един тип, толкова по-различни стойности може да представлява, но в същото време също така консумира повече място в паметта:`_signed_ short _int_``signed short``short int``short` и `char`

|Size|Unique representable values|Notes|
|---|---|---|
|8-bit|`256`|= 28|
|16-bit|`65 536`|= 216|
|32-bit|`4 294 967 296`|= 232 (~4 billion)|
|64-bit|`18 446 744 073 709 551 616`|= 264 (~18 billion billion)|

За целочислените типове наличието на повече представими стойности означава, че диапазонът от стойности, които те могат да представят, е по-голям; например 16-битово цяло число без знак би могло да представи 65536 отделни стойности в диапазона от 0 до 65535, докато неговият аналог със знак би могъл да представи в повечето случаи стойности между -32768 и 32767. Обърнете внимание, че диапазонът от положителните стойности са приблизително наполовина в типовете със знак в сравнение с типовете без знак, поради факта, че един от 16-те бита се използва за знака; това е сравнително скромна разлика в обхвата и рядко оправдава използването на неподписани типове въз основа единствено на обхвата от положителни стойности, които те могат да представят.  
  
За типовете с плаваща запетая размерът влияе на тяхната прецизност, като има повече или по-малко битове за техните значими и експоненти.  
  
Ако размерът или точността на типа не е проблем, тогава `char`, `int`и `double`обикновено се избират да представят съответно знаци, цели числа и стойности с плаваща запетая. Другите типове в съответните им групи се използват само в много специални случаи.

Свойствата на фундаменталните типове в конкретна реализация на система и компилатор могат да бъдат получени чрез използване на[числови_лимити](https://cplusplus.com/numeric_limits)класове (вижте стандартната заглавка `[<limits>](https://cplusplus.com/%3Climits%3E)`). Ако по някаква причина са необходими типове със специфични размери, библиотеката дефинира определени псевдоними на типове с фиксиран размер в заглавката `[<cstdint>](https://cplusplus.com/%3Ccstdint%3E)`.  
  
Типовете, описани по-горе (символи, цели числа, с плаваща запетая и булеви) са общо известни като аритметични типове. Но съществуват два допълнителни основни типа: `void`, който идентифицира липсата на тип; и типа `nullptr`, който е специален тип указател. И двата типа ще бъдат обсъдени допълнително в следваща глава за указателите.  
  
C++ поддържа голямо разнообразие от типове, базирани на основните типове, обсъдени по-горе; тези други типове са известни като _съставни типове данни_ и са една от основните силни страни на езика C++. Също така ще ги видим по-подробно в следващите глави.

### Декларация на променливи

C++ е строго типизиран език и изисква всяка променлива да бъде декларирана със своя тип преди първата си употреба. Това информира компилатора за размера, който да резервира в паметта за променливата и как да интерпретира нейната стойност. Синтаксисът за деклариране на нова променлива в C++ е ясен: просто записваме типа, последван от името на променливата (т.е. нейния идентификатор). Например:

```cpp
int a;
float mynumber;
```

Това са две валидни декларации на променливи. Първият декларира променлива от тип `int`с идентификатор `a`. Вторият декларира променлива от тип `float`с идентификатор `mynumber`. Веднъж декларирани, променливите `a`и `mynumber`могат да се използват в останалата част от техния обхват в програмата.  
Ако декларирате повече от една променлива от един и същи тип, всички те могат да бъдат декларирани в един израз, като разделите идентификаторите си със запетаи. Например:

```cpp
int a, b, c;
```

Това декларира три променливи ( `a`, `b`и `c`), като всички те са от тип `int`и имат точно същото значение като:

```cpp
int a;
int b;
int c;
```

За да видите как изглеждат декларациите на променливи в действие в една програма, нека да разгледаме целия C++ код на примера за вашата умствена памет, предложен в началото на тази глава:

```cpp
// operating with variables

#include <iostream>
using namespace std;

int main ()
{
  // declaring variables:
  int a, b;
  int result;

  // process:
  a = 5;
  b = 2;
  a = a + 1;
  result = a - b;

  // print out the result:
  cout << result;

  // terminate the program:
  return 0;
}
```

- Output: 4

### Инициализация на променливи

Когато променливите в примера по-горе са декларирани, те имат неопределена стойност, докато не им бъде присвоена стойност за първи път. Но е възможно една променлива да има определена стойност от момента, в който е декларирана. Това се нарича _инициализация_ на променливата.  
  
В C++ има три начина за инициализиране на променливи. Всички те са еквивалентни и напомнят за еволюцията на езика през годините:  
  
Първият, известен като _c-подобна инициализация_ (защото е наследен от езика C), се състои от добавяне на знак за равенство, последван от стойността, към която променливата е инициализирана:  
  
`type identifier = initial_value;`  
Например, за да декларираме променлива от тип `int`called `x`и да я инициализирате до стойност нула от същия момент, когато е декларирана, можем да напишем:

```cpp
int x = 0;
```

Втори метод, известен като _инициализация на конструктор_ (въведен от езика C++), затваря началната стойност между скоби ( `()`):  
  
`type identifier (initial_value);`  
Например:

```cpp
int x (0);
```

И накрая, трети метод, известен като _унифицирана инициализация_ , подобен на горния, но използващ фигурни скоби ( `{}`) вместо скоби (това беше въведено от преразглеждането на стандарта C++ през 2011 г.):
  
`type identifier {initial_value};`  
Например:

```cpp
int x {0};
```

```cpp
// initialization of variables

#include <iostream>
using namespace std;

int main ()
{
  int a=5;               // initial value: 5
  int b(3);              // initial value: 3
  int c{2};              // initial value: 2
  int result;            // initial value undetermined

  a = a + b;
  result = a - c;
  cout << result;

  return 0;
}
```

### Приспадане на типа: auto и decltype

Когато се инициализира нова променлива, компилаторът може да разбере какъв е типът на променливата автоматично от инициализатора. За това е достатъчно да използвате `auto`като спецификатор на типа за променливата:

```cpp
int foo = 0;
auto bar = foo;  // the same as: int bar = foo;
```

Тук `bar`се декларира като имащ `auto`тип; следователно типът на `bar`е типът на стойността, използвана за инициализиране: в този случай той използва типа на `foo`, който е `int`.  
  
Променливите, които не са инициализирани, също могат да използват дедукция на типа със `decltype`спецификатора:

```cpp
int foo = 0;
decltype(foo) bar;  // the same as: int bar;
```

Тук `bar`се декларира като имащ същия тип като `foo`.  
  
`auto`и `decltype` са мощни функции, добавени наскоро към езика. Но функциите за дедукция на тип, които въвеждат, са предназначени да се използват или когато типът не може да бъде получен по друг начин, или когато използването му подобрява четимостта на кода. Двата примера по-горе вероятно не са нито един от тези случаи на употреба. Всъщност те вероятно са намалили четливостта, тъй като, когато четете кода, човек трябва да търси типа на , `foo`за да знае действително типа на `bar`.

### Въведение в низовете

Фундаменталните типове представляват най-основните типове, управлявани от машините, където може да се изпълнява кодът. Но една от основните силни страни на езика C++ е неговият богат набор от съставни типове, от които основните типове са просто градивни елементи.  
  
Пример за съставен тип е `string`класът. Променливите от този тип могат да съхраняват поредици от знаци, като думи или изречения. Много полезна функция!  
  
Първата разлика с основните типове данни е, че за да декларира и използва обекти (променливи) от този тип, програмата трябва да включи заглавката, където типът е дефиниран в стандартната библиотека (заглавка ( header ) `<string>`):

```cpp
// my first string
#include <iostream>
#include <string>
using namespace std;

int main ()
{
  string mystring;
  mystring = "This is a string";
  cout << mystring;
  return 0;
}
```

Както можете да видите в предишния пример, низовете могат да бъдат инициализирани с всеки валиден низов литерал, точно както променливите от числов тип могат да бъдат инициализирани с всеки валиден числов литерал. Както при основните типове, всички формати за инициализация са валидни с низове:

```cpp
string mystring = "This is a string";
string mystring ("This is a string");
string mystring {"This is a string"};
```

Низовете могат също така да изпълняват всички други основни операции, които основните типове данни могат, като например да бъдат декларирани без първоначална стойност и да променят стойността си по време на изпълнение:

```cpp
// my first string
#include <iostream>
#include <string>
using namespace std;

int main ()
{
  string mystring;
  mystring = "This is the initial string content";
  cout << mystring << endl;
  mystring = "This is a different string content";
  cout << mystring << endl;
  return 0;
}
```

Забележка: вмъкването на `endl` манипулатора **завършва** с **реда** (отпечатване на знак за нов ред и изчистване на потока).

# Константи

Константите са изрази с фиксирана стойност.

### Литерали

Литералите са най-очевидният вид константи. Те се използват за изразяване на определени стойности в изходния код на програма. Вече използвахме някои в предишни глави, за да дадем конкретни стойности на променливи или да изразим съобщения, които искахме нашите програми да отпечатат, например, когато написахме:

```cpp
a = 5;
```

`5` в тази част от кода беше _буквална константа_ .

Литералните константи могат да бъдат класифицирани като: цели числа, с плаваща запетая, знаци, низове, булеви, указатели и дефинирани от потребителя литерали.

###### Цели числа

```cpp
1776
707
-
```

Това са числени константи, които идентифицират цели числа. Забележете, че те не са оградени в кавички или друг специален знак; те са проста последователност от цифри, представляващи цяло число в десетична основа; например `1776`винаги представлява стойността _хиляда седемстотин седемдесет и шест_ .  
  
В допълнение към десетичните числа (тези, които повечето от нас използват всеки ден), C++ позволява използването на осмични числа (база 8) и шестнадесетични числа (база 16) като буквални константи. За осмични литерали цифрите се предхождат от `0`знак (нула). А за шестнадесетични, те се предхождат от знаците `0x`(нула, x). Например, следните буквални константи са еквивалентни една на друга:

```cpp
75         // decimal
0113       // octal
0x4b       // hexadecimal 
```

Всички те представляват едно и също число: 75 (седемдесет и пет), изразено съответно като число с основа 10, осмично число и шестнадесетично число.  
  
Тези буквални константи имат тип, точно като променливите. По подразбиране целочислените литерали са от тип `int`. Някои суфикси обаче могат да бъдат добавени към целочислен литерал, за да се укаже различен тип цяло число:

|Суфикс|Тип модификатор|
|---|---|
|`u` _или_ `U`|`unsigned`|
|`l` _или_ `L`|`long`|
|`ll` _или_ `LL`|`long long`|

Unsigned може да се комбинира с който и да е от другите два в произволен ред на форма `unsigned long`или `unsigned long long`.

```cpp
75         // int
75u        // unsigned int
75l        // long
75ul       // unsigned long 
75lu       // unsigned long
```

Във всички случаи по-горе суфиксът може да бъде определен с главни или малки букви.

###### Числа с плаваща запетая

Те изразяват реални стойности с десетични знаци и/или експоненти. Те могат да включват или десетична запетая, `e`знак (който изразява _"с десет на X-та височина"_ , където _X_ е цяло число, което следва `e`знака), или както десетична запетая, така и `e` знак:

```cpp
3.14159    // 3.14159
6.02e23    // 6.02 x 10^23
1.6e-19    // 1.6 x 10^-19
3.0        // 3.0  
```

Това са четири валидни числа с десетични знаци, изразени в C++. Първото число е PI, второто е числото на Авогадро, третото е електрическият заряд на електрона (изключително малко число) - всички те са приблизително - и последното е числото _три,_ изразено като плаващ точка числов литерал.  
  
Типът по подразбиране за литерали с плаваща запетая е `double`. Литералите с плаваща запетая от тип `float`или `long double`могат да бъдат посочени чрез добавяне на един от следните наставки:

|Суфикс|Тип|
|---|---|
|`f` _или_ `F`|`float`|
|`l` _или_ `L`|`long double`|

```cpp
3.14159L   // long double
6.02e23f   // float  
```

Всяка от буквите, които могат да бъдат част от числова константа с плаваща запетая ( `e`, `f`, `l`), може да бъде написана с малки или главни букви без разлика в значението.

###### Символни и низови литерали

Символните и низови литерали са оградени в кавички:

```cpp
'z'
'p'
"Hello world"
"How do you do?"
```

Първите два израза представляват _едносимволни литерали_ , а следващите два представляват _низови литерали,_ съставени от няколко знака. Забележете, че за да представим един знак, ние го поставяме в единични кавички ( `'`), а за да изразим низ (който обикновено се състои от повече от един знак), поставяме символите в двойни кавички ( `"`).  
  
Както еднознаковите, така и низовите литерали изискват кавички около тях, за да ги разграничат от възможни идентификатори на променливи или запазени ключови думи. Обърнете внимание на разликата между тези два израза: Тук само ще се отнася до идентификатор, като името на променлива или съставен тип, докато (оградено в единични кавички) ще се отнася до литерала на символа (знака, който представлява малка буква _x_ буква). Символните и низовите литерали могат също да представляват специални символи, които е трудно или невъзможно да се изразят по друг начин в изходния код на програма, като нов ред ( ) или табулация ( ). Всички тези специални знаци са предшествани от обратна наклонена черта ( ). Тук имате списък с кодове за избягване на един символ:

`x   'x'   `  
`x``'x'``'x'`  
  
`\n``\t``\`

|Код за бягство|Описание|
|---|---|
|`\n`|нов ред|
|`\r`|връщане на каретка|
|`\t`|раздел|
|`\v`|вертикален раздел|
|`\b`|назад|
|`\f`|емисия на формуляр (емисия на страница)|
|`\a`|предупреждение (бипкане)|
|`\'`|единични кавички ( `'`)|
|`\"`|двойни кавички ( `"`)|
|`\?`|въпросителен знак ( `?`)|
|`\\`|обратна наклонена черта ( `\`)|

Например: Вътрешно компютрите представят знаци като цифрови кодове: най-често те използват едно разширение на системата за кодиране на знаци [ASCII](https://cplusplus.com/ascii) (вижте [ASCII код](https://cplusplus.com/ascii) за повече информация). Знаците могат също да бъдат представени в литерали, като се използва техният цифров код чрез записване на обратна наклонена черта ( ), последвана от кода, изразен като осмично (база-8) или шестнадесетично (база-16) число. За осмична стойност обратната наклонена черта е последвана директно от цифрите; докато за шестнадесетичен знак се вмъква между обратната наклонена черта и самите шестнадесетични цифри (например: или ). Няколко низови литерала могат да бъдат конкатенирани, за да образуват един низов литерал, просто като ги разделят с едно или повече празни интервала, включително раздели, нови редове и други валидни празни знаци.

```cpp
"this forms" "a single"     " string "
"of characters"
```

Горното е низов литерал, еквивалентен на:

```cpp
"this formsa single string of characters"
```

Забележете как интервалите в кавичките са част от литерала, докато тези извън тях не са.  
  
Някои програмисти също използват трик, за да включат дълги низови литерали в множество редове: В C++ обратната наклонена черта ( `\`) в края на реда се счита за знак _за продължение на реда_ , който обединява този и следващия ред в един ред. Следователно следният код:

```cpp
x = "string expressed in \
two lines"
```

е еквивалентно на:

```cpp
x = "string expressed in two lines"
```

Всички символни литерали и низови литерали, описани по-горе, са съставени от символи от тип `char`. Различен тип знаци може да бъде указан чрез използване на един от следните префикси:

|Префикс|Тип символ|
|---|---|
|`u`|`char16_t`|
|`U`|`char32_t`|
|`L`|`wchar_t`|

Обърнете внимание, че за разлика от суфиксите на типове за целочислени литерали, тези префикси са _чувствителни към главни и малки букви_ : малки букви за `char16_t`и главни букви за `char32_t`и `wchar_t`.  
  
За низови литерали, освен горните `u`, `U`и `L`съществуват два допълнителни префикса:

|Префикс|Описание|
|---|---|
|`u8`|Низовият литерал е кодиран в изпълнимия файл с помощта на UTF-8|
|`R`|Низовият литерал е необработен низ|

В необработените низове обратно наклонените черти и единичните и двойните кавички са валидни знаци; съдържанието на литерала е ограничено от начален и краен , където е всяка последователност от знаци (включително празна последователност). Съдържанието на низа е това, което се намира вътре в скобите, игнорирайки самата разделителна последователност. Например:`R"_sequence_(``)_sequence_"``_sequence_`

```cpp
R"(string with \backslash)"
R"&%$(string with \backslash)&%$"
```

И двата низа по-горе са еквивалентни на `"string with \\backslash"`. Префиксът `R`може да се комбинира с всякакви други префикси, като `u`, `L`или `u8`.

###### Други литерали

В C++ съществуват три ключови литерала: `true`, `false`и `nullptr`:  

- `true`и `false`са двете възможни стойности за променливи от тип `bool`.
- `nullptr`е стойността на _нулевия указател_ .

```cpp
bool foo = true;
bool bar = false;
int* p = nullptr;
```

### Типизирани постоянни изрази

Понякога е просто удобно да дадете име на постоянна стойност:

```cpp
const double pi = 3.1415926;
const char tab = '\t';
```

```cpp
#include <iostream>
using namespace std;

const double pi = 3.14159;
const char newline = '\n';

int main ()
{
  double r = 5.0;               // radius
  double circle;

  circle = 2 * pi * r;
  cout << circle;
  cout << newline;
}
```

### Дефиниции на препроцесора (#define)

Друг механизъм за именуване на константни стойности е използването на дефиниции на препроцесора. Те имат следната форма:  
  
`#define identifier replacement`  
  
След тази директива всяко появяване на `identifier`в кода се интерпретира като `replacement`, където заместването е всяка последователност от знаци (до края на реда). Тази замяна се извършва от препроцесора и се случва преди програмата да бъде компилирана, като по този начин причинява нещо като сляпа замяна: валидността на включените типове или синтаксис не се проверява по никакъв начин.

```cpp
#include <iostream>
using namespace std;

#define PI 3.14159
#define NEWLINE '\n'

int main ()
{
  double r = 5.0;               // radius
  double circle;

  circle = 2 * PI * r;
  cout << circle;
  cout << NEWLINE;

}
```

Обърнете внимание, че `#define`редовете са директиви на предпроцесора и като такива са едноредови инструкции, които - за разлика от операторите на C++ - не изискват точка и запетая (;) в края; директивата продължава автоматично до края на реда. Ако точка и запетая е включена в реда, тя е част от последователността за заместване и също така е включена във всички заменени срещания.

# Оператори

### Оператор за присвояване (=)

Операторът за присвояване присвоява стойност на променлива.

```cpp
x = 5;
```

Този оператор присвоява целочислената стойност `5` на променливата `x`. Операцията за присвояване винаги се извършва отдясно наляво и никога обратното:

```cpp
x = y;
```

Този оператор присвоява на променливата `x`стойността, съдържаща се в променливата `y`. Стойността на `x`в момента на изпълнение на този оператор се губи и се заменя със стойността на `y`.  
  
Имайте предвид също, че присвояваме само стойността на `y`към `x`в момента на операцията за присвояване. Следователно, ако `y` се промени в по-късен момент, това няма да повлияе на новата стойност, взета от `x`.  
  
Например, нека да разгледаме следния код - включил съм развитието на съдържанието, съхранено в променливите като коментари:

```cpp
// assignment operator
#include <iostream>
using namespace std;

int main ()
{
  int a, b;         // a:?,  b:?
  a = 10;           // a:10, b:?
  b = 4;            // a:10, b:4
  a = b;            // a:4,  b:4
  b = 7;            // a:4,  b:7

  cout << "a:";
  cout << a;
  cout << " b:";
  cout << b;
}
```

Тази програма отпечатва на екрана крайните стойности на `a`и `b`(съответно 4 и 7). Забележете как `a`не беше засегнат от окончателната модификация на `b`, въпреки че декларирахме `a = b` по-рано.  
  
Операциите за присвояване са изрази, които могат да бъдат оценени. Това означава, че самото присвояване има стойност и - за фундаментални типове - тази стойност е присвоената в операцията. Например:

```cpp
y = 2 + (x = 5);
```

В този израз `y`се присвоява резултатът от добавянето на 2 и стойността на друг израз за присвояване (който сам по себе си има стойност 5). Това е приблизително еквивалентно на:

```cpp
x = 5;
y = 2 + x;
```

С крайния резултат от присвояването на 7 на `y`.  
  
Следният израз също е валиден в C++:

```cpp
x = y = z = 5;
```

Той присвоява 5 и на трите променливи: `x`, `y`и `z`; винаги отдясно наляво.

### Аритметични оператори ( +, -, *, /, % )

|оператор|описание|
|---|---|
|`+`|допълнение|
|`-`|изваждане|
|`*`|умножение|
|`/`|разделение|
|`%`|по модул|

Операциите събиране, изваждане, умножение и деление съответстват буквално на съответните им математически оператори. Последният, _модулен оператор_ , представен със знак за процент ( `%`), дава остатъка от деление на две стойности. Например:

```cpp
x = 11 % 3;
```

води до променлива, `x` съдържаща стойността 2, тъй като разделянето на 11 на 3 води до 3, с остатък 2.

### Сложно присвояване (+=, -=, *=, /=, %=, >>=, <<=, &=, ^=, |=)

Операторите за съставно присвояване променят текущата стойност на променлива, като извършват операция върху нея. Те са еквивалентни на присвояване на резултата от операция на първия операнд:

|изразяване|еквивалентен на...|
|---|---|
|`y += x;`|`y = y + x;`|
|`x -= 5;`|`x = x - 5;`|
|`x /= y;`|`x = x / y;`|
|`price *= units + 1;`|`price = price * (units+1);`|

```cpp
// compound assignment operators
#include <iostream>
using namespace std;

int main ()
{
  int a, b = 3;
  a = b;
  a += 2;             // equivalent to a=a+2
  cout << a;
}
```

### Увеличаване и намаляване (++, --)

Някои изрази могат да бъдат съкратени още повече: операторът за увеличаване ( `++`) и операторът за намаляване ( `--`) увеличават или намаляват с единица стойността, съхранена в променлива. Те са еквивалентни съответно на `+=1`и на `-=1`. Така:

```cpp
++x;
x += 1;
x = x + 1;
```

всички са еквивалентни по своята функционалност; тримата увеличават с единица стойността на `x`.  
  
В ранните C компилатори трите предишни израза може да са произвели различен изпълним код в зависимост от това кой е бил използван. В днешно време този тип оптимизация на код обикновено се извършва автоматично от компилатора, като по този начин трите израза трябва да произвеждат точно същия изпълним код.  
  
Особеност на този оператор е, че може да се използва както като префикс, така и като суфикс. Това означава, че може да се запише или преди името на променливата ( `++x`), или след него ( `x++`). Въпреки че в прости изрази като `x++`или `++x`, и двата имат точно същото значение; в други изрази, в които се оценява резултатът от операцията за увеличаване или намаляване, те може да имат важна разлика в значението си: В случай, че операторът за увеличаване се използва като префикс ( `++x`) на стойността, изразът се оценява до крайния стойност на `x`, след като вече е увеличена. От друга страна, в случай че се използва като суфикс ( `x++`), стойността също се увеличава, но изразът се оценява на стойността, която x имаше преди да бъде увеличен. Забележете разликата:

|Пример 1|Пример 2|
|---|---|
|`x = 3;   y = ++x;   // x contains 4, y contains 4   `|`x = 3;   y = x++;   // x contains 4, y contains 3   `|

В _Пример 1_ стойността, присвоена на `y` е стойността на `x`след увеличаване. Докато в _Пример 2_ това е стойността, `x` която е имала преди да бъде увеличена.

### Оператори за релация и сравнение ( == , != , > , < , >= , <= )

Два израза могат да бъдат сравнени с помощта на релационни оператори и оператори за равенство. Например, за да разберете дали две стойности са равни или едната е по-голяма от другата.  
  
Резултатът от такава операция е или истина, или невярно (т.е. булева стойност).  
  
Релационните оператори в C++ са:

|оператор|описание|
|---|---|
|`==`|Равно на|
|`!=`|Не е равно на|
|`<`|По-малко от|
|`>`|По-голямо от|
|`<=`|По-малко или равно на|
|`>=`|По-голямо или равно на|

```cpp
(7 == 5)     // evaluates to false
(5 > 4)      // evaluates to true
(3 != 2)     // evaluates to true
(6 >= 6)     // evaluates to true
(5 < 5)      // evaluates to false 
```

Разбира се, не само числови константи могат да бъдат сравнени, но всяка стойност, включително, разбира се, променливи. Да предположим `a=2`, че , `b=3`и `c=6`, тогава:

```cpp
(a == 5)     // evaluates to false, since a is not equal to 5
(a*b >= c)   // evaluates to true, since (2*3 >= 6) is true
(b+4 > a*c)  // evaluates to false, since (3+4 > 2*6) is false
((b=2) == a) // evaluates to true
```

Бъдете внимателни! Операторът за присвояване (оператор `=`, с един знак за равенство) не е същият като оператора за сравнение на равенство (оператор `==`, с два знака за равенство); първият ( `=`) присвоява стойността отдясно на променливата отляво, докато другият ( `==`) сравнява дали стойностите от двете страни на оператора са равни. Следователно в последния израз ( `(b=2) == a`), първо присвоихме стойността `2`на `b`и след това я сравнихме с `a`(който също съхранява стойността 2), давайки `true`.

### Логически оператори ( !, &&, || )

Операторът `!` е C++ операторът за булевата операция NOT. Той има само един операнд, отдясно, и го обръща, произвеждайки `false`дали неговият операнд е `true`, и `true`ако неговият операнд е `false`. По принцип той връща противоположната булева стойност на оценката на неговия операнд. Например:

```cpp
!(5 == 5)   // evaluates to false because the expression at its right (5 == 5) is true
!(6 <= 4)   // evaluates to true because (6 <= 4) would be false
!true       // evaluates to false
!false      // evaluates to true
```

Логическите оператори `&&`и `||`се използват при изчисляване на два израза за получаване на един релационен резултат. Операторът `&&`съответства на булевата логическа операция И, която дава резултат, `true`ако и двата й операнда са `true`, и `false`в противен случай. Следният панел показва резултата от оператора, `&&`оценяващ израза `a&&b`:

|&& ОПЕРАТОР (и)|   |   |
|---|---|---|
|`a`|`b`|`a && b`|
|`true`|`true`|`true`|
|`true`|`false`|`false`|
|`false`|`true`|`false`|
|`false`|`false`|`false`|

Операторът `||`съответства на булевата логическа операция ИЛИ, която дава резултат , `true`ако някой от нейните операнди е `true`, като по този начин е false само когато и двата операнда са false. Ето възможните резултати от `a||b`:

|\| ОПЕРАТОР (или)|   |   |
|---|---|---|
|`a`|`b`|`a \| b`|
|`true`|`true`|`true`|
|`true`|`false`|`true`|
|`false`|`true`|`true`|
|`false`|`false`|`false`|

```cpp
( (5 == 5) && (3 > 6) )  // evaluates to false ( true && false )
( (5 == 5) || (3 > 6) )  // evaluates to true ( true || false ) 
```

Когато използва логическите оператори, C++ оценява само това, което е необходимо отляво надясно, за да излезе с комбинирания релационен резултат, като игнорира останалото. Следователно, в последния пример ( `(5==5)||(3>6)`), C++ първо оценява дали `5==5`е `true`и ако е така, никога не проверява дали `3>6`е `true`или не. Това е известно като _оценка на късо съединение_ и работи по следния начин за тези оператори:

|оператор|късо съединение|
|---|---|
|`&&`|ако изразът от лявата страна е `false`, комбинираният резултат е `false`(изразът от дясната страна никога не се оценява).|
|`\|`|ако изразът от лявата страна е `true`, комбинираният резултат е `true`(изразът от дясната страна никога не се оценява).|

Това е най-важно, когато десният израз има странични ефекти, като например промяна на стойности:

```cpp
if ( (i<10) && (++i<n) ) { /*...*/ }   // note that the condition increments i 
```

Тук комбинираният условен израз ще се увеличи `i`с единица, но само ако условието отляво на `&&`е `true`, защото в противен случай условието от дясната страна ( `++i<n`) никога не се оценява.

### Условен троичен оператор ( ? )

Условният оператор изчислява израз, като връща една стойност, ако този израз се изчисли на `true`, и друга, ако изразът се изчисли като `false`. Синтаксисът му е:

condition ? result1 : result2

Ако `condition`е `true`, целият израз се оценява на `result1`, а в противен случай на `result2`.

```cpp
7==5 ? 4 : 3     // evaluates to 3, since 7 is not equal to 5.
7==5+2 ? 4 : 3   // evaluates to 4, since 7 is equal to 5+2.
5>3 ? a : b      // evaluates to the value of a, since 5 is greater than 3.
a>b ? a : b      // evaluates to whichever is greater, a or b.  
```

```cpp
// conditional operator
#include <iostream>
using namespace std;

int main ()
{
  int a,b,c;

  a=2;
  b=7;
  c = (a>b) ? a : b;

  cout << c << '\n';
}
```

В този пример `a` беше 2 и `b` беше 7, така че изразът, който се оценява ( `a>b`), не беше `true`, следователно първата стойност, посочена след въпросителния знак, беше отхвърлена в полза на втората стойност (тази след двоеточието), която беше `b` (с стойност от 7).

### Оператор със запетая ( , )

Операторът запетая ( `,`) се използва за разделяне на два или повече израза, които са включени там, където се очаква само един израз. Когато наборът от изрази трябва да бъде оценен за стойност, се взема предвид само най-десният израз.

```cpp
a = (b=3, b+2);
```

първо ще присвои стойността 3 на `b`и след това ще присвои `b+2`на променлива `a`. Така че в края променливата `a`ще съдържа стойност 5, докато променливата `b`ще съдържа стойност 3.

### Побитови оператори ( &, |, ^, ~, <<, >> )

Побитовите оператори модифицират променливите, като вземат предвид битовите модели, които представляват стойностите, които съхраняват.

|оператор|asm еквивалент|описание|
|---|---|---|
|`&`|`AND`|Побитово И|
|`\|`|`OR`|Побитово включващо ИЛИ|
|`^`|`XOR`|Побитово изключително ИЛИ|
|`~`|`NOT`|Унарно допълнение (битова инверсия)|
|`<<`|`SHL`|Преместване на битове наляво|
|`>>`|`SHR`|Преместете битовете надясно|

### Явен оператор за преобразуване на типове

Операторите за преобразуване на тип позволяват преобразуване на стойност от даден тип в друг тип. Има няколко начина да направите това в C++. Най-простият, който е наследен от езика C, е да предхожда израза, който трябва да бъде преобразуван от новия тип, ограден между скоби (()):

```cpp
int i;
float f = 3.14;
i = (int) f;
```

Предишният код преобразува числото с плаваща запетая `3.14`в цяло число ( `3`); остатъкът се губи. Тук операторът за преобразуване на типове беше `(int)`. Друг начин да направите същото нещо в C++ е да използвате функционалната нотация, предшестваща израза, който трябва да бъде преобразуван от типа, и ограждайки израза между скоби:

```cpp
i = int (f);
```

### sizeof

Този оператор приема един параметър, който може да бъде или тип, или променлива, и връща размера в байтове на този тип или обект:

```cpp
x = sizeof (char);
```

Тук `x` се присвоява стойността `1`, тъй като `char`е тип с размер от един байт.  
  
Стойността, върната от, `sizeof`е константа по време на компилиране, така че винаги се определя преди изпълнението на програмата.

От най-големия до най-малкия приоритет, C++ операторите се оценяват в следния ред:  

|Ниво|Група с приоритет|Оператор|Описание|Групиране|
|---|---|---|---|---|
|1|Обхват|`::`|квалификатор на обхват|Отляво надясно|
|2|Постфикс (унарен)|`++ --`|постфикс инкремент / декремент|Отляво надясно|
|`()`|функционални форми|
|`[]`|долен индекс|
|`. ->`|членски достъп|
|3|Префикс (унарен)|`++ --`|префикс увеличение / намаляване|От дясно на ляво|
|`~ !`|побитово НЕ / логическо НЕ|
|`+ -`|унарен префикс|
|`& *`|референция / дереференция|
|`new delete`|разпределение / освобождаване|
|`sizeof`|пакет с параметри|
|`(_type_)`|Отливка в стил C|
|4|Указател към член|`.* ->*`|указател за достъп|Отляво надясно|
|5|Аритметика: мащабиране|`* / %`|умножение, деление, модул|Отляво надясно|
|6|Аритметика: събиране|`+ -`|събиране, изваждане|Отляво надясно|
|7|Побитово изместване|`<< >>`|преместване наляво, преместване надясно|Отляво надясно|
|8|Релационни|`< > <= >=`|оператори за сравнение|Отляво надясно|
|9|Равенство|`== !=`|равенство / неравенство|Отляво надясно|
|10|И|`&`|побитово И|Отляво надясно|
|11|Изключително или|`^`|побитово XOR|Отляво надясно|
|12|Включително или|`\|`|побитово ИЛИ|Отляво надясно|
|13|Съединение|`&&`|логично И|Отляво надясно|
|14|Дизюнкция|`\|`|логическо ИЛИ|Отляво надясно|
|15|Изрази на ниво задание|`= *= /= %= += -=   >>= <<= &= ^= \|=`|задача / съставна задача|От дясно на ляво|
|`?:`|условен оператор|
|16|Секвениране|`,`|разделител със запетая|Отляво надясно|

Когато един израз има два оператора с едно и също ниво на приоритет, _групирането_ определя кой от тях се оценява първи: или отляво надясно, или отдясно наляво.  
  
Заграждането на всички подизявления в скоби (дори тези, които не са необходими поради техния приоритет) подобрява четливостта на кода.

# Основен Вход/Изход

Примерните програми от предишните раздели осигуряват малко взаимодействие с потребителя, ако изобщо има такова. Те просто отпечатват прости стойности на екрана, но стандартната библиотека предоставя много допълнителни начини за взаимодействие с потребителя чрез функциите за вход/изход. Този раздел ще представи кратко въведение в някои от най-полезните.  
  
C++ използва удобна абстракция, наречена _потоци,_ за извършване на входни и изходни операции в последователни медии като екрана, клавиатурата или файл. Потокът е обект , в който програмата може или да вмъква, или да извлича знаци към/от. Не е необходимо да знаете подробности за медиите, свързани с потока, или някоя от вътрешните му спецификации. Всичко, което трябва да знаем е, че потоците са източник/дестинация на символи и че тези символи се предоставят/приемат последователно (т.е. един след друг).  
  
Стандартната библиотека дефинира шепа обекти на поток, които могат да се използват за достъп до това, което се счита за стандартни източници и местоназначения на символи от средата, в която се изпълнява програмата:

|поток|описание|
|---|---|
|`cin`|стандартен входен поток|
|`cout`|стандартен изходен поток|
|`cerr`|стандартен поток за грешка (изход).|
|`clog`|стандартен поток за регистриране (изход).|

### Стандартен изход (cout)

В повечето програмни среди стандартният изход по подразбиране е екранът, а обектът C++ поток, дефиниран за достъп до него, е `cout`.  
  
За форматирани изходни операции `cout`се използва заедно с _оператора за вмъкване_ , който се записва като `<<`(т.е. два знака "по-малко от").

```cpp
cout << "Output sentence"; // prints Output sentence on screen
cout << 120;               // prints number 120 on screen
cout << x;                 // prints the value of x on screen
```

### Стандартен вход (cin)

В повечето програмни среди стандартният вход по подразбиране е клавиатурата, а обектът C++ поток, дефиниран за достъп до него, е `cin`.  
  
За форматирани входни операции `cin`се използва заедно с оператора за извличане, който се записва като `>>`(т.е. два знака "по-голямо от"). След това този оператор е последван от променливата, където се съхраняват извлечените данни. Например:

```c++
int age;
cin >> age;
```

Първият израз декларира променлива от тип , `int`наречен `age`, а вторият извлича от `cin`стойност, която да бъде съхранена в нея. Тази операция кара програмата да чака вход от `cin`; обикновено това означава, че програмата ще изчака потребителя да въведе някаква последователност с клавиатурата. В този случай имайте предвид, че знаците, въведени с помощта на клавиатурата, се предават на програмата само при натискане на клавиша ENTER  (или ). RETURN. След като се достигне операторът с включена операция за извличане `cin`, програмата ще изчака толкова дълго, колкото е необходимо, докато бъде въведен някакъв вход.  
  
Операцията за извличане on `cin`използва типа на променливата след `>>`оператора, за да определи как интерпретира символите, прочетени от входа; ако е цяло число, очакваният формат е поредица от цифри, ако низ е последователност от знаци и т.н.

```c++
#include <iostream>
using namespace std;

int main ()
{
  int i;
  cout << "Please enter an integer value: ";
  cin >> i;
  cout << "The value you entered is " << i;
  cout << " and its double is " << i*2 << ".\n";
  return 0;
}
```

Моля, въведете цяло число: 702 
Въведената стойност е 702, а произведението е 1404.

Какво се случва в горния пример, ако потребителят въведе нещо друго, което не може да се интерпретира като цяло число? Е, в този случай операцията по извличане е неуспешна. И това по подразбиране позволява на програмата да продължи, без да зададе стойност за променлива `i`, произвеждайки неопределени резултати, ако стойността на `i`се използва по-късно.  
  
Това е много лошо поведение на програмата. Повечето програми се очаква да се държат по очаквания начин, без значение какво въвежда потребителят, като обработват невалидните стойности по подходящ начин. Само много прости програми трябва да разчитат на стойности, извлечени директно от `cin`без допълнителна проверка. Малко по-късно ще видим как _стринговите потоци_ могат да се използват за по-добър контрол върху потребителското въвеждане.  
Извличанията на `cin`също могат да бъдат верижни, за да поискат повече от една информация в едно изявление:

```c++
cin >> a >> b;
```

Това е еквивалентно на:


```c++
cin >> a;
cin >> b;
```

И в двата случая се очаква потребителят да въведе две стойности, една за променлива `a`и друга за променлива `b`. Всеки вид интервал се използва за разделяне на две последователни операции за въвеждане; това може да бъде интервал, табулация или символ за нов ред.

### cin и string

Операторът за извличане може да се използва `cin`за получаване на низове от знаци по същия начин, както при основните типове данни:

```c++
string mystring;
cin >> mystring;
```

Извличането обаче `cin`винаги разглежда интервали (празни интервали, табулатори, нов ред...) като завършващи стойността, която се извлича, и по този начин извличането на низ означава винаги да извличате една дума, а не фраза или цяло изречение.  
  
За да получите цял ред от `cin`, съществува функция, наречена `getline`, която приема потока ( `cin`) като първи аргумент и низовата променлива като втори. Например:

```c++
// cin with strings
#include <iostream>
#include <string>
using namespace std;

int main ()
{
  string mystr;
  cout << "What's your name? ";
  getline (cin, mystr);
  cout << "Hello " << mystr << ".\n";
  cout << "What is your favorite team? ";
  getline (cin, mystr);
  cout << "I like " << mystr << " too!\n";
  return 0;
}
```

Забележете как и в двете извиквания на `getline`използвахме един и същ идентификатор на низ ( `mystr`). Това, което програмата прави при второто извикване, е просто да замени предишното съдържание с новото, което се въвежда.  
  
Стандартното поведение, което повечето потребители очакват от конзолна програма, е, че всеки път, когато програмата пита потребителя за въвеждане, потребителят въвежда полето и след това натиска ENTER(или RETURN). С други думи, въвеждането обикновено се очаква да се случи по отношение на редове на конзолни програми и това може да се постигне чрез използване `getline`за получаване на въвеждане от потребителя. Следователно, освен ако нямате сериозна причина да не го правите, винаги трябва да използвате, `getline`за да получите вход във вашите конзолни програми, вместо да извличате от `cin`.

### Низов поток

Стандартното заглавие `[<sstream>](https://cplusplus.com/%3Csstream%3E)`дефинира тип, наречен `[stringstream](https://cplusplus.com/stringstream)`, който позволява низ да бъде третиран като поток и по този начин позволява операции за извличане или вмъкване от/към низове по същия начин, както се изпълняват на `cin`и `cout`. Тази функция е най-полезна за преобразуване на низове в числови стойности и обратно. Например, за да извлечем цяло число от низ, можем да напишем:

```c++
string mystr ("1204");
int myint;
stringstream(mystr) >> myint;
```

Това декларира a `string`с инициализирано до стойност от `"1204"`и променлива от тип `int`. След това третият ред използва тази променлива, за да извлече от `stringstream`конструиран от низа. Тази част от кода съхранява числената стойност `1204`в променливата, наречена `myint`.

# Структура на програмата

### Statement-и и контрол на потока (flow control)

Един прост израз на C++ е всяка отделна инструкция на програма, като декларациите на променливи и изразите, видяни в предишните раздели. Те винаги завършват с точка и запетая ( `;`) и се изпълняват в същия ред, в който се появяват в програмата.  
  
Но програмите не се ограничават до линейна последователност от изрази. По време на своя процес програмата може да повтаря сегменти от код или да взема решения и да се раздвоява. За тази цел C++ предоставя изрази за контрол на потока, които служат за указване какво трябва да се направи от нашата програма, кога и при какви обстоятелства.  
  
Много от изразите за управление на потока, обяснени в този раздел, изискват общ (под)израз като част от своя синтаксис. Този statement може да бъде или прост C++ statement - като единична инструкция, завършващо с точка и запетая ( `;`) - или съставен statement. Съставният израз е група от изрази (всеки от тях завършва със собствена точка и запетая), но всички групирани заедно в блок, ограден във фигурни скоби: {}:

{ statement1; statement2; statement3; }

Целият блок се счита за единичен израз (съставен от множество sub statements) . Всеки път, когато общ оператор е част от синтаксиса на оператор за управление на потока, това може да бъде или прост оператор, или съставен оператор.

### Statement-и за избор: if & else

Ключовата `if`дума се използва за изпълнение на израз или блок, ако и само ако дадено условие е изпълнено. Синтаксисът му е:  
  
`if (condition) statement`  
  
Тук `condition`е изразът, който се оценява. Ако това `condition`е вярно, `statement`се изпълнява. Ако е невярно, `statement`не се изпълнява (просто се игнорира) и програмата продължава веднага след целия оператор за избор.  
Например, следният кодов фрагмент отпечатва съобщението `(x is 100)`само ако стойността, съхранена в `x`променливата, наистина е 100:

```cpp
if (x == 100)
  cout << "x is 100";
```

Ако `x`не е точно 100, този оператор се игнорира и нищо не се отпечатва.  
  
Ако искате да включите повече от един оператор, който да бъде изпълнен, когато условието е изпълнено, тези оператори трябва да бъдат оградени в скоби ( `{}`), образувайки блок:

```cpp
if (x == 100)
{
   cout << "x is ";
   cout << x;
}
```

Както обикновено, отстъпите и прекъсванията на редовете в кода нямат ефект, така че горният код е еквивалентен на:

```cpp
if (x == 100) { cout << "x is "; cout << x; }
```

Statement-ите за избор с `if`могат също да уточнят какво се случва, когато условието не е изпълнено, като използват `else`ключовата дума за въвеждане на алтернативен израз. Синтаксисът му е: където се изпълнява в случай, че условието е вярно, а в случай че не е, се изпълнява. Например:

`if (condition) statement1 else statement2   `

`statement1 statement2`

```cpp
if (x == 100)
  cout << "x is 100";
else
  cout << "x is not 100";
```

Това отпечатва `x is 100`, ако наистина x има стойност 100, но ако не е и само ако не е, отпечатва `x is not 100`вместо това.  
Няколко if + else структури могат да бъдат свързани с намерението да се провери диапазон от стойности. Например:

```cpp
if (x > 0)
  cout << "x is positive";
else if (x < 0)
  cout << "x is negative";
else
  cout << "x is 0";
```

Това отпечатва дали x е положително, отрицателно или нула чрез свързване на две if-else структури. Отново би било възможно да се изпълнят повече от един израз за случай, като се групират в блокове, затворени в скоби: `{}`.

### Statement-и за итерация (цикли)

Циклите повтарят оператор определен брой пъти или докато дадено условие е изпълнено. Те се въвеждат с ключовите думи `while`, `do`и `for`.  
  

#### Цикълът while

Най-простият вид цикъл е цикълът while. Синтаксисът му е: Цикълът while просто повтаря докато е вярно. Ако след всяко изпълнение на вече не е вярно, цикълът приключва и програмата продължава веднага след цикъла. Например, нека да разгледаме обратното броене с помощта на цикъл while:

`while (expression) statement   `  

`statement expression statement expression`

```cpp
// custom countdown using while
#include <iostream>
using namespace std;

int main ()
{
  int n = 10;

  while (n>0) {
    cout << n << ", ";
    --n;
  }

  cout << "liftoff!\n";
}
```

Първият израз в `main`задава n на стойност 10. Това е първото число в обратното броене. След това започва цикълът while: ако тази стойност изпълнява условието `n>0`(че n е по-голямо от нула), тогава блокът, който следва условието, се изпълнява и се повтаря толкова дълго, колкото условието ( `n>0`) остава вярно.  
  
Целият процес на предишната програма може да се интерпретира според следния скрипт (започващ в `main`):  
  

1. `n`е присвоена стойност
2. Условието `while`е проверено ( `n>0`). На този етап има две възможности:  
    - условието е вярно: операторът се изпълнява (до стъпка 3)  
        
    - условието е невярно: игнорирайте оператора и продължете след него (до стъпка 5)  
        
3. Изявление за изпълнение: (отпечатва стойността на и намалява с 1)  
    `cout << n << ", ";   --n;   
    `nn`  
    
1. Край на блока. Автоматично връщане към стъпка 2.
2. Продължете програмата веднага след блока:  
    отпечатайте `liftoff!`и завършете програмата.

Нещо, което трябва да имате предвид при циклите while е, че цикълът трябва да приключи в даден момент и по този начин операторът ще промени стойностите, проверени в условието по някакъв начин, така че да го принуди да стане невярно в даден момент. В противен случай цикълът ще продължи да се повтаря завинаги. В този случай цикълът включва `--n`, което намалява стойността на променливата, която се оценява в условието ( `n`) с единица - това в крайна сметка ще направи условието ( `n>0`) невярно след определен брой повторения на цикъла. За да бъдем по-конкретни, след 10 итерации `n`става 0, което прави условието вече невярно и прекратява цикъла while.  
  
Обърнете внимание, че сложността на този цикъл е тривиална за компютър и така цялото обратно броене се извършва незабавно, без каквото и да е практическо забавяне между елементите на броенето.

#### Цикълът do-while

Много подобен цикъл е цикълът do-while, чийто синтаксис е: Той се държи като цикъл while, с изключение на това, че се оценява след изпълнението на вместо преди, гарантирайки поне едно изпълнение на , дори ако никога не е изпълнено. Например следната примерна програма повтаря всеки текст, въведен от потребителя, докато потребителят не въведе Exit и т.н.:

`do statement while (condition);   `

`condition statement statement condition`

```cpp
// echo machine
#include <iostream>
#include <string>
using namespace std;

int main ()
{
  string str;
  do {
    cout << "Enter text: ";
    getline (cin,str);
    cout << "You entered: " << str << '\n';
  } while (str != "goodbye");
}
```

Цикълът do-while обикновено се предпочита пред цикъла while, когато `statement`трябва да се изпълни поне веднъж, като например когато условието, което се проверява до края на цикъла, се определя в самия оператор на цикъла. В предишния пример въведеното от потребителя в блока е това, което ще определи дали цикълът ще приключи. И по този начин, дори ако потребителят иска да прекрати цикъла възможно най-скоро, като влезедовиждане, блокът в цикъла трябва да се изпълни поне веднъж, за да се подкани за въвеждане и условието може всъщност да бъде определено само след като бъде изпълнено.

#### Цикълът for

Цикълът `for`е проектиран да се повтаря няколко пъти. Синтаксисът му е: Подобно на цикъла while, този цикъл се повтаря, докато е вярно. Но освен това цикълът for предоставя специфични местоположения за съдържане на израз и израз, изпълнени преди цикълът да започне за първи път и съответно след всяка итерация. Следователно е особено полезно да се използват променливи на брояча като . Работи по следния начин:

`for (initialization; condition; increase) statement;   `

`statement condition initialization increase condition`

1. `initialization`се изпълнява. Обикновено това декларира променлива на брояча и я задава на някаква първоначална стойност. Това се изпълнява еднократно, в началото на цикъла.
2. `condition`се проверява. Ако е вярно, цикълът продължава; в противен случай цикълът завършва и `statement`се пропуска, преминавайки директно към стъпка 5.
3. `statement`се изпълнява. Както обикновено, това може да бъде или единичен израз, или блок, ограден във фигурни скоби `{ }`.
4. `increase`се изпълнява и цикълът се връща към стъпка 2.
5. цикълът завършва: изпълнението продължава със следващия оператор след него.

Ето примера за обратно броене с използване на for цикъл:

```cpp
#include <iostream>
using namespace std;

int main ()
{
  for (int n=10; n>0; n--) {
    cout << n << ", ";
  }
  cout << "liftoff!\n";
}
```

Трите полета във for-цикъла не са задължителни. Те могат да бъдат оставени празни, но във всички случаи знакът точка и запетая между тях е задължителен. Например, `for (;n<10;)`е цикъл без _инициализация_ или _увеличение_ (еквивалентен на цикъл while); и `for (;n<10;++n)`е цикъл с _увеличение_ , но без _инициализация_ (може би защото променливата вече е била инициализирана преди цикъла). Цикъл без _условие_ е еквивалентен на цикъл с `true`условие (т.е. безкраен цикъл).  
  
Тъй като всяко от полетата се изпълнява в определено време в жизнения цикъл на цикъл, може да е полезно да се изпълнят повече от един израз като _инициализация_ , _условие_ или _оператор_ . За съжаление, това не са инструкции, а по-скоро прости изрази и следователно не могат да бъдат заменени с блок. Като изрази обаче те могат да използват оператора запетая ( `,`): Този оператор е разделител на изрази и може да разделя множество изрази, където обикновено се очаква само един. Например, използвайки го, би било възможно for цикъл да обработва две променливи на брояча, като инициализира и увеличава и двете:

```cpp
for ( n=0, i=100 ; n!=i ; ++n, --i )
{
   // whatever here...
}
```

Този цикъл ще се изпълни 50 пъти, ако нито едно от `n`двете `i`не е променено в рамките на цикъла:

![[Pasted image 20241220160151.png]]

`n`започва със стойност 0, а `i`със 100 условието е `n!=i`(т.е. това `n`не е равно на `i`). Тъй като `n`се увеличава с единица и `i`намалява с единица на всяка итерация, условието на цикъла ще стане невярно след 50-ата итерация, когато и двете `n`са `i`равни на 50.

#### Базиран на диапазон for цикъл

For-цикълът има друг синтаксис, който се използва изключително с диапазони: Този вид for цикъл итерира всички елементи в , където декларира някаква променлива, която може да приеме стойността на елемент в този диапазон. Диапазоните са поредици от елементи, включително масиви, контейнери и всеки друг тип, поддържащ функциите  
  
`for ( declaration : range ) statement;   `  

Пример за базиран на диапазон for цикъл, използващ низове:

```cpp
#include <iostream>
#include <string>
using namespace std;

int main ()
{
  string str {"Hello!"};
  for (char c : str)
  {
    cout << "[" << c << "]";
  }
  cout << '\n';
}
```

Обърнете внимание как това, което предхожда двоеточието ( `:`) в for цикъла, е декларацията на `char`променлива (елементите в низ са от тип `char`). След това използваме тази променлива, `c`, в блока с инструкции, за да представим стойността на всеки от елементите в диапазона.  
  
Този цикъл е автоматичен и не изисква изрично деклариране на която и да е променлива на брояча.  
  
Циклите, базирани на диапазон, обикновено също използват дедукция на типа за типа на елементите с `auto`. Обикновено цикълът, базиран на обхват по-горе, може също да бъде написан като:

```cpp
for (auto c : str)
  cout << "[" << c << "]";
```

Тук типът на `c`автоматично се извежда като тип на елементите в `str`.

### Statement-и Jump

Инструкциите за прескачане позволяват промяна на потока на програма чрез извършване на прескачане до определени места.

#### Statement за прекъсване

`break`оставя цикъл, дори ако условието за края му не е изпълнено. Може да се използва за прекратяване на безкраен цикъл или за принудително завършване преди естествения му край. Например, нека спрем обратното броене преди естествения му край:

```cpp
#include <iostream>
using namespace std;

int main ()
{
  for (int n=10; n>0; n--)
  {
    cout << n << ", ";
    if (n==3)
    {
      cout << "countdown aborted!";
      break;
    }
  }
}
```

#### Statement за продължаване

Statement-а `continue`кара програмата да пропусне останалата част от цикъла в текущата итерация, сякаш краят на блока с изявления е достигнат, карайки програмата да премине към началото на следващата итерация. Например, нека пропуснем номер 5 в нашето обратно броене:

```cpp
#include <iostream>
using namespace std;

int main ()
{
  for (int n=10; n>0; n--) {
    if (n==5) continue;
    cout << n << ", ";
  }
  cout << "liftoff!\n";
}
```

#### Инструкцията goto

`goto`позволява да се направи абсолютен скок към друга точка в програмата. Този безусловен скок игнорира нивата на влагане и не предизвиква автоматично размотаване на стека. Следователно е функция, която трябва да се използва внимателно и за предпочитане в рамките на един и същи блок от изрази, особено при наличието на локални променливи.  
  
Точката на дестинация се идентифицира с _етикет_ , който след това се използва като аргумент за `goto`израза. Етикетът се състои от валиден идентификатор _,_ последван от двоеточие ( `:`).  
  
`goto`обикновено се счита за функция от ниско ниво, без конкретни случаи на употреба в съвременните парадигми за програмиране от по-високо ниво, които обикновено се използват с C++. Но само като пример, ето версия на нашия цикъл за обратно броене, използващ goto:

```cpp
#include <iostream>
using namespace std;

int main ()
{
  int n=10;
mylabel:
  cout << n << ", ";
  n--;
  if (n>0) goto mylabel;
  cout << "liftoff!\n";
}
```

### Друг Statement за избор: switch

Синтаксисът на оператора switch е малко странен. Неговата цел е да провери за стойност сред редица възможни константни изрази. Това е нещо подобно на конкатенирането `if`- `else`statement-и, но ограничено до постоянни изрази. Най-типичният му синтаксис е:

код>превключвател (израз)   
{   
  case constant1:   
     group-of-statements-1;   
     прекъсване;   
  случайна константа2:   
     група-изявления-2;   
     прекъсване;   
  .   
  .   
  .   
  по подразбиране:   
     група-от-изявления по подразбиране   
} 
/код>

Работи по следния начин: `switch`оценява `expression`и проверява дали е еквивалентен на `constant1`; ако е така, той се изпълнява, `group-of-statements-1`докато намери `break`оператора. Когато намери този `break`оператор, програмата скача до края на целия `switch`оператор (затварящата скоба).  
  
Ако изразът не е равен на `constant1`, тогава се проверява срещу `constant2`. Ако е равно на това, той се изпълнява, `group-of-statements-2`докато бъде намерено a `break`, когато скача до края на превключвателя.  
  
И накрая, ако стойността на израза не съответства на нито една от предварително зададените константи (може да има произволен брой такива), програмата изпълнява операторите, включени след етикета `default:`, ако съществува (тъй като не е задължителен).  
  
И двата от следните кодови фрагменти имат едно и също поведение, демонстрирайки еквивалента на if-else на израз за превключване:

| пример за превключване                                                                                                                                                                                                                                       | if-else еквивалент                                                                                                                                                                               |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| код>превключвател (x) {   <br>  случай 1:   <br>    cout <br> "x е 1";   <br>    прекъсване;   <br>  case 2:   <br>    cout <br> "x е 2";   <br>    прекъсване;   <br>  по подразбиране:   <br>    cout <br> "неизвестна стойност на x";   <br>  } <br>/код> | код>ако (x == 1) {   <br>  cout <br> "x е 1";   <br>}   <br>else if (x == 2) {   <br>  cout <br> "x е 2";   <br>}   <br>else {   <br>  cout <br> "неизвестна стойност на x";   <br>}   <br>/код> |

Statement-a `switch`има донякъде особен синтаксис, наследен от ранните времена на първите C компилатори, защото използва етикети вместо блокове. При най-типичната употреба (показана по-горе) това означава, че `break`са необходими изрази след всяка група изрази за определен етикет. Ако не е включено, всички изрази след case (включително тези под всякакви други етикети) също се изпълняват, докато се достигне `break`края на блока за превключване или оператор за прескачане (като ). Ако в примера по-горе липсва операторът break след първата група за случай едно, програмата няма да скочи автоматично до края на блока за превключване след отпечатване и вместо това ще продължи да изпълнява операторите в случай две (по този начин ще отпечата също ). След това ще продължи да прави това , докато се срещне оператор или края на блока. Това прави ненужно ограждането на изразите за всеки случай в скоби и може също да бъде полезно за изпълнение на една и съща група изрази за различни възможни стойности. Например:`break`

```cpp
switch (x) {
  case 1:
  case 2:
  case 3:
    cout << "x is 1, 2 or 3";
    break;
  default:
    cout << "x is not 1, 2 nor 3";
  }
```

Забележете, че `switch`е ограничено да сравнява своя оценен израз с етикети, които са постоянни изрази. Не е възможно да използвате променливи като етикети или диапазони, тъй като те не са валидни C++ константни изрази.

### Функции

Функциите позволяват да се структурират програми в сегменти от код за изпълнение на отделни задачи.  
  
В C++ функцията е група от изрази, на които е дадено име и които могат да бъдат извикани от някаква точка на програмата. Най-често срещаният синтаксис за дефиниране на функция е:

type name ( parameter1, parameter2, ...) { statements }

- `type` е типът на стойността, върната от функцията.
- `name` е идентификаторът, с който може да се извика функцията.  
- `parameters` (колкото е необходимо): Всеки параметър се състои от тип, последван от идентификатор, като всеки параметър е отделен от следващия със запетая. Всеки параметър изглежда много като обикновена декларация на променлива (например: int x ) и всъщност действа във функцията като обикновена променлива, която е локална за функцията. Целта на параметрите е да позволят предаването на аргументи към функцията от мястото, откъдето е извикана.
- `statements` е тялото на функцията. Това е блок от изрази, оградени със скоби { }, които указват какво всъщност прави функцията.

```cpp
#include <iostream>
using namespace std;

int addition (int a, int b)
{
  int r;
  r=a+b;
  return r;
}

int main ()
{
  int z;
  z = addition (5,3);
  cout << "The result is " << z;
}
```

Тази програма е разделена на две функции: `addition`и `main`. Не забравяйте, че независимо от реда, в който са дефинирани, C++ програма винаги започва с извикване `main`. Всъщност `main`това е единствената функция, която се извиква автоматично, а кодът във всяка друга функция се изпълнява само ако нейната функция е извикана от `main`(директно или косвено).  
  
В примера по-горе `main`започва с деклариране на променлива `z`от тип `int`и веднага след това изпълнява първото извикване на функция: извиква `addition`. Извикването на функция следва структура, много подобна на нейната декларация. В примера по-горе извикването на `addition`може да се сравни с дефиницията му само няколко реда по-рано:

![[Pasted image 20241220161832.png]]

Параметрите в декларацията на функцията имат ясно съответствие с аргументите, предадени в извикването на функцията. Извикването предава две стойности `5`и `3`, на функцията; те съответстват на параметрите `a`и `b`, декларирани за функция `addition`.  
  
В точката, в която функцията се извиква от main, контролът се предава на функцията `addition`: тук изпълнението на `main`е спряно и ще се възобнови едва след като `addition`функцията приключи. В момента на извикването на функцията, стойността на двата аргумента ( `5`и `3`) се копират в локалните променливи `int a`и `int b`във функцията.  
  
След това вътре `addition`се декларира друга локална променлива ( `int r`) и с помощта на израза `r=a+b`резултатът от `a`плюс `b`се присвоява на `r`; което за този случай, където `a`е 5 и `b`е 3, означава, че 8 е присвоено на `r`.

Крайният статемент в рамките на функцията:

```cpp
return r;
```

Завършва функцията `addition`и връща управлението обратно до точката, където е извикана функцията; в този случай: да функционира `main`. Точно в този момент програмата възобновява курса си, като `main`се връща точно в същата точка, в която е била прекъсната от извикването на `addition`. Но освен това, тъй като `addition`има тип връщане, извикването се оценява като имащо стойност и тази стойност е стойността, посочена в оператора за връщане, който е завършил `addition`: в този конкретен случай, стойността на локалната променлива `r`, която в момента на `return`операторът имаше стойност 8.

![[Pasted image 20241220162004.png]]

Следователно извикването на `addition`е израз със стойността, върната от функцията, и в този случай тази стойност, 8, е присвоена на `z`. Сякаш цялото извикване на функция ( `addition(5,3)`) е заменено от стойността, която връща (т.е. 8).  
  
Тогава main просто отпечатва тази стойност чрез извикване:

```cpp
cout << "The result is " << z;
```

Една функция всъщност може да бъде извикана няколко пъти в рамките на една програма и нейният аргумент естествено не е ограничен само до литерали:

```cpp
#include <iostream>
using namespace std;

int subtraction (int a, int b)
{
  int r;
  r=a-b;
  return r;
}

int main ()
{
  int x=5, y=3, z;
  z = subtraction (7,2);
  cout << "The first result is " << z << '\n';
  cout << "The second result is " << subtraction (7,2) << '\n';
  cout << "The third result is " << subtraction (x,y) << '\n';
  z= 4 + subtraction (x,y);
  cout << "The fourth result is " << z << '\n';
}
```

Подобно на `addition`функцията в предишния пример, този пример дефинира `subtract`функция, която просто връща разликата между двата си параметъра. Този път `main`извиква тази функция няколко пъти, демонстрирайки повече възможни начини, по които може да бъде извикана дадена функция.  
  
Нека разгледаме всяко от тези извиквания, като имаме предвид, че всяко извикване на функция само по себе си е израз, който се оценява като стойността, която връща. Отново можете да мислите за това така, сякаш самото извикване на функция е заменено от върнатата стойност:

```cpp
z = subtraction (7,2);
cout << "The first result is " << z;
```

Ако заменим извикването на функцията със стойността, която връща (т.е. 5), ще имаме:

```cpp
z = 5;
cout << "The first result is " << z;
```

Със същата процедура можем да интерпретираме:

```cpp
cout << "The second result is " << subtraction (7,2);
```

като:

```cpp
cout << "The second result is " << 5;
```

тъй като 5 е стойността, върната от `subtraction (7,2)`.

В случай на:

```cpp
cout << "The third result is " << subtraction (x,y);
```

Аргументите, предавани на изваждането, са променливи вместо литерали. Това също е валидно и работи добре. Функцията се извиква със стойностите `x`и `y`имат в момента на извикването: съответно 5 и 3, връщайки 2 като резултат.  
  
Четвъртото обаждане отново е подобно:

```cpp
z = 4 + subtraction (x,y);
```

Единственото допълнение е, че сега извикването на функцията също е операнд на операция за събиране. Отново, резултатът е същият, както ако извикването на функцията беше заменено от нейния резултат: 6. Обърнете внимание, че благодарение на комутативното свойство на добавките, горното може да бъде записано и като:

```cpp
z = subtraction (x,y) + 4;
```

С абсолютно същия резултат. Обърнете внимание също, че точката и запетая не е задължително след извикването на функцията, но, както винаги, в края на целия оператор. Отново, логиката зад може лесно да се види отново, като се заменят извикванията на функции с тяхната върната стойност:

```cpp
z = 4 + 2;    // same as z = 4 + subtraction (x,y);
z = 2 + 4;    // same as z = subtraction (x,y) + 4; 
```

### Функции без тип. Използването на void

Синтаксисът, показан по-горе за функции: Изисква декларацията да започва с тип. Това е типът на стойността, върната от функцията. Но какво ще стане, ако функцията не трябва да върне стойност? В този случай типът, който ще се използва, е , който е специален тип за представяне на липсата на стойност. Например, функция, която просто отпечатва съобщение, може да не е необходимо да връща никаква стойност:  
  
`type name ( argument1, argument2 ...) { statements }   `  

`void`

```cpp
#include <iostream>
using namespace std;

void printmessage ()
{
  cout << "I'm a function!";
}

int main ()
{
  printmessage ();
}
```

`void`може също да се използва в списъка с параметри на функцията, за да се посочи изрично, че функцията не приема действителни параметри, когато се извиква. Например `printmessage`може да бъде деклариран като:

```cpp
void printmessage (void)
{
  cout << "I'm a function!";
}
```

В C++ може да се използва празен списък с параметри вместо `void`със същото значение, но използването на `void`в списъка с аргументи беше популяризирано от езика C, където това е изискване.  
  
Нещо, което в никакъв случай не е задължително, са скобите, които следват името на функцията, нито в нейната декларация, нито при нейното извикване. И дори когато функцията не приема никакви параметри, към името на функцията винаги трябва да се добавят поне една празна двойка скоби. Вижте как `printmessage`беше извикано в по-ранен пример:

```cpp
printmessage ();
```

Скобите са това, което отличава функциите от други видове декларации или изрази. Следното няма да извика функцията:

```cpp
printmessage;
```

### Върнатата стойност (return) на main

Може да сте забелязали, че типът връщане на `main`е `int`, но повечето примери в тази и по-ранните глави всъщност не връщат никаква стойност от `main`.  
  
Е, има една уловка: ако изпълнението на `main`приключи нормално, без да се натъкне на `return`оператор, компилаторът приема, че функцията завършва с косвен оператор за връщане:

```cpp
return 0;
```

Обърнете внимание, че това се отнася само за функция `main`по исторически причини. Всички други функции с тип връщане трябва да завършват с подходящ `return`оператор, който включва връщана стойност, дори ако това никога не се използва.  
  
Когато `main`върне нула (имплицитно или явно), това се интерпретира от средата като че програмата е приключила успешно. Други стойности могат да бъдат върнати от `main`и някои среди дават достъп до тази стойност на извикващия по някакъв начин, въпреки че това поведение не е задължително, нито непременно преносимо между платформи. Стойностите за `main`които гарантирано се интерпретират по един и същи начин на всички платформи са:

| стойност       | описание                                                                                                 |
| -------------- | -------------------------------------------------------------------------------------------------------- |
| `0`            | Програмата беше успешна                                                                                  |
| `EXIT_SUCCESS` | Програмата беше успешна (същата като по-горе).  <br>Тази стойност е дефинирана в заглавката `<cstdlib>`. |
| `EXIT_FAILURE` | Програмата се провали.  <br>Тази стойност е дефинирана в заглавката `<cstdlib>`                          |

Тъй като имплицитното `return 0;`изявление for `main`е сложно изключение, някои автори смятат, че е добра практика изрично да се напише изявлението.

### Аргументи, предавани по стойност и по референция

Във функциите, разгледани по-рано, аргументите винаги са били предавани _по стойност_ . Това означава, че при извикване на функция това, което се предава на функцията, са стойностите на тези аргументи в момента на извикването, които се копират в променливите, представени от параметрите на функцията. Например вземете:

```cpp
int x=5, y=3, z;
z = addition ( x, y );
```

В този случай добавянето на функция се предава 5 и 3, които са копия на стойностите на `x`и `y`съответно. Тези стойности (5 и 3) се използват за инициализиране на променливите, зададени като параметри в дефиницията на функцията, но всяка модификация на тези променливи в рамките на функцията няма ефект върху стойностите на променливите x и y извън нея, тъй като x и y са били самите те не се предават на функцията при повикването, а само копия на техните стойности в този момент.

![[Pasted image 20241220163349.png]]

В някои случаи обаче може да е полезно достъпът до външна променлива от функцията. За да направите това, аргументите могат да се предават _по референция , вместо _по стойност_ . Например, функцията `duplicate`в този код дублира стойността на трите си аргумента, което кара променливите, използвани като аргументи, да бъдат действително модифицирани от извикването:

```cpp
#include <iostream>
using namespace std;

void duplicate (int& a, int& b, int& c)
{
  a*=2;
  b*=2;
  c*=2;
}

int main ()
{
  int x=1, y=3, z=7;
  duplicate (x, y, z);
  cout << "x=" << x << ", y=" << y << ", z=" << z;
  return 0;
}
```

За да получи достъп до своите аргументи, функцията декларира своите параметри като _референции_ . В C++ референциите се обозначават с амперсанд ( `&`) след типа на параметъра, както в параметрите, взети от `duplicate`в примера по-горе.  
  
Когато една променлива се предава _по референция_ , това, което се предава, вече не е копие, но самата променлива, променливата, идентифицирана от параметъра на функцията, по някакъв начин се свързва с аргумента, предаден на функцията, и всяка модификация на съответните им локални променливи в рамките функцията се отразяват в променливите, предадени като аргументи в извикването.

![[Pasted image 20241220163552.png]]

Всъщност , `a`, `b`и `c`стават псевдоними на аргументите, предадени при извикването на функцията ( `x`, `y`, и `z`) и всяка промяна `a`във функцията всъщност е модифицираща променлива `x`извън функцията. Всяка промяна на `b`модифицира `y`и всяка промяна на `c`модифицира `z`. Ето защо, когато в примера функцията `duplicate`променя стойностите на променливите `a`, `b`, и `c`, стойностите на `x`, `y`и `z`са засегнати.  
  
Ако вместо да дефинирате дубликат като:

```cpp
void duplicate (int& a, int& b, int& c)
```

Трябваше ли да се дефинира без знаците амперсанд като:

```cpp
void duplicate (int a, int b, int c)
```

Променливите няма да бъдат предавани _по референция_ , а _по стойност_ , създавайки вместо това копия на техните стойности. В този случай изходът на програмата би бил стойностите на `x`, `y`и `z`без да бъде модифициран (т.е. 1, 3 и 7).

### Съображения за ефективност и const референции

..................